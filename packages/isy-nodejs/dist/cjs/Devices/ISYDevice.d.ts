import { Family } from '../Definitions/Global/Families.js';
import { EndpointType, MutableEndpoint } from '@project-chip/matter.js/endpoint/type';
import { Endpoint } from '@project-chip/matter.js/endpoint';
import { SupportedBehaviors } from '@project-chip/matter.js/endpoint/properties';
import { ClusterBehavior } from '@project-chip/matter.js/behavior/cluster';
import 'winston';
import { ISYDeviceNode, type DriverValues, type ISYDevice } from '../ISYNode.js';
import { Constructor } from './Constructor.js';
import { UnitOfMeasure } from '../Definitions/Global/UOM.js';
import { DriverType, type Driver } from '../Definitions/Global/Drivers.js';
export declare const ISYBinaryStateDevice: <K extends Family, D extends Driver.Literal, T extends Constructor<ISYDeviceNode<K, D | "ST", any>>>(Base: T) => {
    new (...args: any[]): {
        readonly state: Promise<boolean>;
        convertTo(value: any, uom: UnitOfMeasure, propertyName?: D): boolean;
        convertFrom(value: any, uom: number, propertyName?: D): number;
        family: K;
        readonly typeCode: string;
        readonly deviceClass: any;
        readonly parentAddress: any;
        readonly category: number;
        readonly subCategory: number;
        readonly type: any;
        _parentDevice: ISYDeviceNode<K, Driver.Literal, string>;
        readonly children: ISYDeviceNode<K, Driver.Literal, string>[];
        readonly scenes: import("../ISYScene.js").ISYScene[];
        hidden: boolean;
        _enabled: any;
        productName: string;
        model: string;
        modelNumber: string;
        version: string;
        isDimmable: boolean;
        addLink(isyScene: import("../ISYScene.js").ISYScene): void;
        addChild<K_1 extends ISYDeviceNode<K, any, any>>(childDevice: K_1): void;
        readonly parentDevice: ISYDeviceNode<K, Driver.Literal, string>;
        readProperty(propertyName: Driver.Literal): Promise<import("../Model/DriverState.js").DriverState>;
        readProperties(): Promise<import("../Model/DriverState.js").DriverState[]>;
        updateProperty(propertyName: Driver.Literal, value: string): Promise<any>;
        sendCommand(command: string, parameters?: Record<string | symbol, string | number> | string | number): Promise<any>;
        refresh(): Promise<any>;
        parseResult(node: {
            property: import("../Model/DriverState.js").DriverState | import("../Model/DriverState.js").DriverState[];
        }): void;
        applyStatus(prop: import("../Model/DriverState.js").DriverState): void;
        handleControlTrigger(controlName: string): boolean;
        handlePropertyChange(driver: any, value: any, formattedValue: string): boolean;
        readonly isy: import("../ISY.js").ISY;
        readonly formatted: DriverValues<"ST" | D, string>;
        readonly uom: { [x in Driver.Literal]?: UnitOfMeasure; };
        readonly pending: DriverValues<"ST" | D, any>;
        readonly local: DriverValues<"ST" | D, any>;
        readonly drivers: ({
            ACCX?: Driver<DriverType>;
            ACCY?: Driver<DriverType>;
            ACCZ?: Driver<DriverType>;
            AIRFLOW?: Driver<DriverType>;
            AQI?: Driver<DriverType>;
            ALARM?: Driver<DriverType>;
            ANGLPOS?: Driver<DriverType>;
            ATMPRES?: Driver<DriverType>;
            ADRPST?: Driver<DriverType>;
            AWAKE?: Driver<DriverType>;
            BARPRES?: Driver<DriverType>;
            BATLVL?: Driver<DriverType>;
            BEEP?: Driver<DriverType>;
            BPDIA?: Driver<DriverType>;
            BPSYS?: Driver<DriverType>;
            BMI?: Driver<DriverType>;
            BONEM?: Driver<DriverType>;
            BRT?: Driver<DriverType>;
            CO?: Driver<DriverType>;
            CO2LVL?: Driver<DriverType>;
            CTL?: Driver<DriverType>;
            CLISPC?: Driver<DriverType>;
            CC?: Driver<DriverType>;
            CPW?: Driver<DriverType>;
            CLITEMP?: Driver<DriverType>;
            CV?: Driver<DriverType>;
            GV0?: Driver<DriverType>;
            GV1?: Driver<DriverType>;
            GV2?: Driver<DriverType>;
            GV3?: Driver<DriverType>;
            GV30?: Driver<DriverType>;
            GV4?: Driver<DriverType>;
            GV5?: Driver<DriverType>;
            GV6?: Driver<DriverType>;
            GV7?: Driver<DriverType>;
            GV8?: Driver<DriverType>;
            GV9?: Driver<DriverType>;
            GV10?: Driver<DriverType>;
            GV11?: Driver<DriverType>;
            GV12?: Driver<DriverType>;
            GV13?: Driver<DriverType>;
            GV14?: Driver<DriverType>;
            GV15?: Driver<DriverType>;
            GV16?: Driver<DriverType>;
            GV17?: Driver<DriverType>;
            GV18?: Driver<DriverType>;
            GV19?: Driver<DriverType>;
            GV20?: Driver<DriverType>;
            GV21?: Driver<DriverType>;
            GV22?: Driver<DriverType>;
            GV23?: Driver<DriverType>;
            GV24?: Driver<DriverType>;
            GV25?: Driver<DriverType>;
            GV26?: Driver<DriverType>;
            GV27?: Driver<DriverType>;
            GV28?: Driver<DriverType>;
            GV29?: Driver<DriverType>;
            DELAY?: Driver<DriverType>;
            DEWPT?: Driver<DriverType>;
            BUSY?: Driver<DriverType>;
            SECMD?: Driver<DriverType>;
            DIM?: Driver<DriverType>;
            DISTANC?: Driver<DriverType>;
            WATERTD?: Driver<DriverType>;
            DUR?: Driver<DriverType>;
            ELECCON?: Driver<DriverType>;
            ELECRES?: Driver<DriverType>;
            CLIEMD?: Driver<DriverType>;
            ERR?: Driver<DriverType>;
            ETO?: Driver<DriverType>;
            TEMPEXH?: Driver<DriverType>;
            FDDOWN?: Driver<DriverType>;
            FDSTOP?: Driver<DriverType>;
            FDUP?: Driver<DriverType>;
            CLIFRS?: Driver<DriverType>;
            CLIFS?: Driver<DriverType>;
            CLIFSO?: Driver<DriverType>;
            DFOF?: Driver<DriverType>;
            DFON?: Driver<DriverType>;
            CH20?: Driver<DriverType>;
            FREQ?: Driver<DriverType>;
            GPV?: Driver<DriverType>;
            GVOL?: Driver<DriverType>;
            GUST?: Driver<DriverType>;
            CLIHCS?: Driver<DriverType>;
            HEATIX?: Driver<DriverType>;
            CLISPH?: Driver<DriverType>;
            HAIL?: Driver<DriverType>;
            HR?: Driver<DriverType>;
            CLIHUM?: Driver<DriverType>;
            LUMIN?: Driver<DriverType>;
            METHANE?: Driver<DriverType>;
            MODE?: Driver<DriverType>;
            MOIST?: Driver<DriverType>;
            MOON?: Driver<DriverType>;
            MUSCLEM?: Driver<DriverType>;
            DOF?: Driver<DriverType>;
            DOF3?: Driver<DriverType>;
            DOF4?: Driver<DriverType>;
            DOF5?: Driver<DriverType>;
            DON?: Driver<DriverType>;
            DON3?: Driver<DriverType>;
            DON4?: Driver<DriverType>;
            DON5?: Driver<DriverType>;
            OL?: Driver<DriverType>;
            OZONE?: Driver<DriverType>;
            PM10?: Driver<DriverType>;
            PM25?: Driver<DriverType>;
            POP?: Driver<DriverType>;
            PPW?: Driver<DriverType>;
            PF?: Driver<DriverType>;
            PRECIP?: Driver<DriverType>;
            PULSCNT?: Driver<DriverType>;
            QUERY?: Driver<DriverType>;
            RADON?: Driver<DriverType>;
            RAINRT?: Driver<DriverType>;
            RELMOD?: Driver<DriverType>;
            RESET?: Driver<DriverType>;
            RESPR?: Driver<DriverType>;
            RFSS?: Driver<DriverType>;
            ROTATE?: Driver<DriverType>;
            CLISMD?: Driver<DriverType>;
            SEISINT?: Driver<DriverType>;
            SEISMAG?: Driver<DriverType>;
            SMOKED?: Driver<DriverType>;
            SOILH?: Driver<DriverType>;
            SOILR?: Driver<DriverType>;
            SOILS?: Driver<DriverType>;
            SOILT?: Driver<DriverType>;
            SOLRAD?: Driver<DriverType>;
            SVOL?: Driver<DriverType>;
            SPEED?: Driver<DriverType>;
            ST?: Driver<DriverType>;
            TANKCAP?: Driver<DriverType>;
            USRNUM?: Driver<DriverType>;
            CLIMD?: Driver<DriverType>;
            TIDELVL?: Driver<DriverType>;
            TIME?: Driver<DriverType>;
            TIMEREM?: Driver<DriverType>;
            TBW?: Driver<DriverType>;
            TPW?: Driver<DriverType>;
            UV?: Driver<DriverType>;
            UAC?: Driver<DriverType>;
            VOCLVL?: Driver<DriverType>;
            WATERF?: Driver<DriverType>;
            WATERP?: Driver<DriverType>;
            WATERT?: Driver<DriverType>;
            WVOL?: Driver<DriverType>;
            WEIGHT?: Driver<DriverType>;
            WINDCH?: Driver<DriverType>;
            WINDDIR?: Driver<DriverType>;
            WATERTB?: Driver<DriverType>;
            TEMPOUT?: Driver<DriverType>;
        } & {
            add(driver: Driver<DriverType>): void;
        }) | import("../Definitions/Global/Drivers.js").DriverList<D>;
        readonly flag: any;
        readonly nodeDefId: string;
        readonly address: string;
        name: string;
        label: string;
        spokenName: string;
        location: string;
        isLoad: boolean;
        folder: string;
        parent: any;
        parentType: import("../ISYConstants.js").NodeType;
        readonly elkId: string;
        nodeType: number;
        readonly baseLabel: string;
        propsInitialized: boolean;
        logger: (msg: any, level?: "error" | "warn" | "debug" | "info", ...meta: any[]) => import("winston").Logger;
        lastChanged: Date;
        enabled: boolean;
        baseName: any;
        on(event: "PropertyChanged" | "ControlTriggered", listener: ((propertyName: string, newValue: any, oldValue: any, formattedValue: string) => any) | ((controlName: string) => any)): any;
        emit(event: "PropertyChanged" | "ControlTriggered", propertyName?: string, newValue?: any, oldValue?: any, formattedValue?: string, controlName?: string): boolean;
        handleEvent(event: {
            control?: any;
            data?: any;
            node?: any;
            action?: any;
            fmtAct?: any;
        }): boolean;
        generateLabel(template: string): string;
        refreshNotes(): Promise<void>;
        getNotes(): Promise<import("../ISYNode.js").NodeNotes>;
        [EventEmitter.captureRejectionSymbol]?(error: Error, event: string, ...args: any[]): void;
        addListener(eventName: string | symbol, listener: (...args: any[]) => void): any;
        once(eventName: string | symbol, listener: (...args: any[]) => void): any;
        removeListener(eventName: string | symbol, listener: (...args: any[]) => void): any;
        off(eventName: string | symbol, listener: (...args: any[]) => void): any;
        removeAllListeners(event?: string | symbol): any;
        setMaxListeners(n: number): any;
        getMaxListeners(): number;
        listeners(eventName: string | symbol): Function[];
        rawListeners(eventName: string | symbol): Function[];
        listenerCount(eventName: string | symbol, listener?: Function): number;
        prependListener(eventName: string | symbol, listener: (...args: any[]) => void): any;
        prependOnceListener(eventName: string | symbol, listener: (...args: any[]) => void): any;
        eventNames(): Array<string | symbol>;
    };
} & T;
export interface ISYBinaryStateDevice {
    get state(): Promise<boolean>;
}
export declare const ISYUpdateableBinaryStateDevice: <K extends Family, D extends Driver.Literal, C extends string, T extends Constructor<ISYDevice<K, D, C | "DON" | "DOF">>>(Base: T) => {
    new (...args: any[]): {
        local: DriverValues<D | DriverType.Status>;
        formatted: DriverValues<D | DriverType.Status, string>;
        pending: DriverValues<D | DriverType.Status>;
        get state(): Promise<boolean>;
        set state(value: boolean);
        On(): Promise<any>;
        Off(): Promise<any>;
        updateState(state: boolean): Promise<any>;
        logger(arg0: string): unknown;
        handleEvent(evt: any): unknown;
        on(arg0: string, arg1: any): unknown;
        name: any;
        uom: { [x in Driver.Literal]?: UnitOfMeasure; };
        drivers: import("../Definitions/Global/Drivers.js").DriverList<D>;
        address: string;
        family: K;
        typeCode: string;
        deviceClass: any;
        parentAddress: any;
        category: number;
        subCategory: number;
        type: any;
        _parentDevice: ISYDeviceNode<K, Driver.Literal, string>;
        children: ISYDeviceNode<K, Driver.Literal, string>[];
        scenes: import("../ISYScene.js").ISYScene[];
        hidden: boolean;
        enabled: boolean;
        productName: string;
        model: string;
        modelNumber: string;
        version: string;
        isDimmable: boolean;
        label: string;
        convertTo(value: any, UnitOfMeasure: number): any;
        convertTo(value: any, UnitOfMeasure: number, propertyName: Driver.Literal): any;
        convertFrom(value: any, UnitOfMeasure: number): any;
        convertFrom(value: any, UnitOfMeasure: number, propertyName: Driver.Literal): any;
        addLink(isyScene: import("../ISYScene.js").ISYScene): void;
        addChild(childDevice: ISYDeviceNode<K, Driver.Literal, string>): void;
        readProperty(propertyName: D): Promise<import("../Model/DriverState.js").DriverState>;
        readProperties(): Promise<import("../Model/DriverState.js").DriverState[]>;
        updateProperty(propertyName: D, value: string): Promise<any>;
        sendCommand(command: "DON" | "DOF" | C, parameters?: Record<string | symbol, string | number> | string | number): Promise<any>;
        refresh(): Promise<any>;
        refreshNotes(): Promise<void>;
        parseResult(node: {
            property: import("../Model/DriverState.js").DriverState | import("../Model/DriverState.js").DriverState[];
        }): void;
        handleControlTrigger(controlName: "DON" | "DOF" | C): boolean;
        handlePropertyChange(propertyName: D, value: any, formattedValue: string): boolean;
    };
} & T;
export interface MapsToEndpointType<T extends EndpointType> {
    initialize(endpoint: Endpoint<T>): void;
}
type BehaviorList<T extends ClusterBehavior> = SupportedBehaviors & T;
export interface MapsToEndpoint<T extends ClusterBehavior> {
    initialize<K extends MutableEndpoint.With<EndpointType.Empty, BehaviorList<T>>>(endpoint: Endpoint<K>): void;
}
export declare const ISYLevelDevice: <T extends Constructor<ISYDeviceNode<any, any, any>>>(base: T) => {
    new (...args: any[]): {
        readonly level: number;
        family: any;
        readonly typeCode: string;
        readonly deviceClass: any;
        readonly parentAddress: any;
        readonly category: number;
        readonly subCategory: number;
        readonly type: any;
        _parentDevice: ISYDeviceNode<any, Driver.Literal, string>;
        readonly children: ISYDeviceNode<any, Driver.Literal, string>[];
        readonly scenes: import("../ISYScene.js").ISYScene[];
        hidden: boolean;
        _enabled: any;
        productName: string;
        model: string;
        modelNumber: string;
        version: string;
        isDimmable: boolean;
        convertTo(value: any, UnitOfMeasure: number, propertyName?: Driver.Literal): any;
        convertFrom(value: any, UnitOfMeasure: number, propertyName?: Driver.Literal): any;
        addLink(isyScene: import("../ISYScene.js").ISYScene): void;
        addChild<K extends ISYDeviceNode<any, any, any>>(childDevice: K): void;
        readonly parentDevice: ISYDeviceNode<any, Driver.Literal, string>;
        readProperty(propertyName: Driver.Literal): Promise<import("../Model/DriverState.js").DriverState>;
        readProperties(): Promise<import("../Model/DriverState.js").DriverState[]>;
        updateProperty(propertyName: Driver.Literal, value: string): Promise<any>;
        sendCommand(command: string, parameters?: Record<string | symbol, string | number> | string | number): Promise<any>;
        refresh(): Promise<any>;
        parseResult(node: {
            property: import("../Model/DriverState.js").DriverState | import("../Model/DriverState.js").DriverState[];
        }): void;
        applyStatus(prop: import("../Model/DriverState.js").DriverState): void;
        handleControlTrigger(controlName: string): boolean;
        handlePropertyChange(driver: any, value: any, formattedValue: string): boolean;
        readonly isy: import("../ISY.js").ISY;
        readonly formatted: DriverValues<any, string>;
        readonly uom: { [x in Driver.Literal]?: UnitOfMeasure; };
        readonly pending: DriverValues<any, any>;
        readonly local: DriverValues<any, any>;
        readonly drivers: {} | ({
            [x: string]: Driver<any>;
        } & {
            add(driver: Driver<any>): void;
        }) | ({} & {
            add(driver: Driver<never>): void;
        });
        readonly flag: any;
        readonly nodeDefId: string;
        readonly address: string;
        name: string;
        label: string;
        spokenName: string;
        location: string;
        isLoad: boolean;
        folder: string;
        parent: any;
        parentType: import("../ISYConstants.js").NodeType;
        readonly elkId: string;
        nodeType: number;
        readonly baseLabel: string;
        propsInitialized: boolean;
        logger: (msg: any, level?: "error" | "warn" | "debug" | "info", ...meta: any[]) => import("winston").Logger;
        lastChanged: Date;
        enabled: boolean;
        baseName: any;
        on(event: "PropertyChanged" | "ControlTriggered", listener: ((propertyName: string, newValue: any, oldValue: any, formattedValue: string) => any) | ((controlName: string) => any)): any;
        emit(event: "PropertyChanged" | "ControlTriggered", propertyName?: string, newValue?: any, oldValue?: any, formattedValue?: string, controlName?: string): boolean;
        handleEvent(event: {
            control?: any;
            data?: any;
            node?: any;
            action?: any;
            fmtAct?: any;
        }): boolean;
        generateLabel(template: string): string;
        refreshNotes(): Promise<void>;
        getNotes(): Promise<import("../ISYNode.js").NodeNotes>;
        [EventEmitter.captureRejectionSymbol]?(error: Error, event: string, ...args: any[]): void;
        addListener(eventName: string | symbol, listener: (...args: any[]) => void): any;
        once(eventName: string | symbol, listener: (...args: any[]) => void): any;
        removeListener(eventName: string | symbol, listener: (...args: any[]) => void): any;
        off(eventName: string | symbol, listener: (...args: any[]) => void): any;
        removeAllListeners(event?: string | symbol): any;
        setMaxListeners(n: number): any;
        getMaxListeners(): number;
        listeners(eventName: string | symbol): Function[];
        rawListeners(eventName: string | symbol): Function[];
        listenerCount(eventName: string | symbol, listener?: Function): number;
        prependListener(eventName: string | symbol, listener: (...args: any[]) => void): any;
        prependOnceListener(eventName: string | symbol, listener: (...args: any[]) => void): any;
        eventNames(): Array<string | symbol>;
    };
} & T;
export declare const ISYUpdateableLevelDevice: <T extends Constructor<ISYDeviceNode<any, any, any>>>(base: T) => {
    new (...args: any[]): {
        readonly level: number;
        updateLevel(level: number): Promise<any>;
        family: any;
        readonly typeCode: string;
        readonly deviceClass: any;
        readonly parentAddress: any;
        readonly category: number;
        readonly subCategory: number;
        readonly type: any;
        _parentDevice: ISYDeviceNode<any, Driver.Literal, string>;
        readonly children: ISYDeviceNode<any, Driver.Literal, string>[];
        readonly scenes: import("../ISYScene.js").ISYScene[];
        hidden: boolean;
        _enabled: any;
        productName: string;
        model: string;
        modelNumber: string;
        version: string;
        isDimmable: boolean;
        convertTo(value: any, UnitOfMeasure: number, propertyName?: Driver.Literal): any;
        convertFrom(value: any, UnitOfMeasure: number, propertyName?: Driver.Literal): any;
        addLink(isyScene: import("../ISYScene.js").ISYScene): void;
        addChild<K extends ISYDeviceNode<any, any, any>>(childDevice: K): void;
        readonly parentDevice: ISYDeviceNode<any, Driver.Literal, string>;
        readProperty(propertyName: Driver.Literal): Promise<import("../Model/DriverState.js").DriverState>;
        readProperties(): Promise<import("../Model/DriverState.js").DriverState[]>;
        updateProperty(propertyName: Driver.Literal, value: string): Promise<any>;
        sendCommand(command: string, parameters?: Record<string | symbol, string | number> | string | number): Promise<any>;
        refresh(): Promise<any>;
        parseResult(node: {
            property: import("../Model/DriverState.js").DriverState | import("../Model/DriverState.js").DriverState[];
        }): void;
        applyStatus(prop: import("../Model/DriverState.js").DriverState): void;
        handleControlTrigger(controlName: string): boolean;
        handlePropertyChange(driver: any, value: any, formattedValue: string): boolean;
        readonly isy: import("../ISY.js").ISY;
        readonly formatted: DriverValues<any, string>;
        readonly uom: { [x in Driver.Literal]?: UnitOfMeasure; };
        readonly pending: DriverValues<any, any>;
        readonly local: DriverValues<any, any>;
        readonly drivers: {} | ({
            [x: string]: Driver<any>;
        } & {
            add(driver: Driver<any>): void;
        }) | ({} & {
            add(driver: Driver<never>): void;
        });
        readonly flag: any;
        readonly nodeDefId: string;
        readonly address: string;
        name: string;
        label: string;
        spokenName: string;
        location: string;
        isLoad: boolean;
        folder: string;
        parent: any;
        parentType: import("../ISYConstants.js").NodeType;
        readonly elkId: string;
        nodeType: number;
        readonly baseLabel: string;
        propsInitialized: boolean;
        logger: (msg: any, level?: "error" | "warn" | "debug" | "info", ...meta: any[]) => import("winston").Logger;
        lastChanged: Date;
        enabled: boolean;
        baseName: any;
        on(event: "PropertyChanged" | "ControlTriggered", listener: ((propertyName: string, newValue: any, oldValue: any, formattedValue: string) => any) | ((controlName: string) => any)): any;
        emit(event: "PropertyChanged" | "ControlTriggered", propertyName?: string, newValue?: any, oldValue?: any, formattedValue?: string, controlName?: string): boolean;
        handleEvent(event: {
            control?: any;
            data?: any;
            node?: any;
            action?: any;
            fmtAct?: any;
        }): boolean;
        generateLabel(template: string): string;
        refreshNotes(): Promise<void>;
        getNotes(): Promise<import("../ISYNode.js").NodeNotes>;
        [EventEmitter.captureRejectionSymbol]?(error: Error, event: string, ...args: any[]): void;
        addListener(eventName: string | symbol, listener: (...args: any[]) => void): any;
        once(eventName: string | symbol, listener: (...args: any[]) => void): any;
        removeListener(eventName: string | symbol, listener: (...args: any[]) => void): any;
        off(eventName: string | symbol, listener: (...args: any[]) => void): any;
        removeAllListeners(event?: string | symbol): any;
        setMaxListeners(n: number): any;
        getMaxListeners(): number;
        listeners(eventName: string | symbol): Function[];
        rawListeners(eventName: string | symbol): Function[];
        listenerCount(eventName: string | symbol, listener?: Function): number;
        prependListener(eventName: string | symbol, listener: (...args: any[]) => void): any;
        prependOnceListener(eventName: string | symbol, listener: (...args: any[]) => void): any;
        eventNames(): Array<string | symbol>;
    };
} & T;
export {};
